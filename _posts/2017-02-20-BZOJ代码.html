---
layout: compress
---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
  <link rel="stylesheet" href="{{site.baseurl}}/css/main.css">
  <link rel="stylesheet" href="{{site.baseurl}}/css/monokai-sublime.css">
  {% seo %}
</head>
<body style="background-color: rgb(255, 255, 255)">
 <script src="{{site.baseurl}}/js/theme.min.js"></script>
  <script src="{{site.baseurl}}/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <header>
      <a href="{{site.baseurl}}/"><div class="home"></div></a>
  </header>




<h1 class="post-headline">BZOJ代码(更新)</h1>
<div class="meta"><span>February 20, 2017</span></div>

<h1 id="1000">1000</h1>
<pre><code class = "c++">#include &lt;iostream&gt;
//居然不是第一题
using namespace std;
int main(){
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;
    cout&lt;&lt;a + b&lt;&lt;endl;
    return 0;
}
</code></pre><h1 id="1001">1001</h1>
<pre><code class = "c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
//By sssSSSay
//Max_Flow
#define INF 100000007
using namespace std;
struct node {int next,val,to;}E[6000010];
int n,m,tot,Ans,dis[1000010],H[1000010],q[1000010];
void Add(int u,int v,int c){E[++tot].next = H[u];E[tot].to = v;E[tot].val = c;H[u] = tot;}
void Link(int u,int v,int c){Add(u,v,c);Add(v,u,c);}
int Num(int x,int y){return (x - 1) * m + y;}
int Bfs(){
    memset(dis,-1,sizeof(dis));
    int h = 1,t = 1;dis[1] = 0;q[h] = 1;
    while(h &lt;= t){
        int u = q[h];
        // printf(&quot;%d :&quot;,u);
        for(int i=H[u];i;i=E[i].next){
            int v = E[i].to;
            // printf(&quot;%d &quot;,v);
            if(dis[v] == -1 &amp;&amp; E[i].val){
                dis[v] = dis[u] + 1;
                q[++t] = v;
            }
        }h++;
        // printf(&quot;\n&quot;);
    }if(dis[n * m] == -1)return 0;
    return 1;
}
int Max_Flow(int x,int Min){
    if(x == n * m)return Min;
    int w,used = 0;
    for(int i=H[x];i;i=E[i].next){
        int v = E[i].to;
        if(E[i].val &amp;&amp; dis[v] == dis[x] + 1){
            w = Min - used;
            w = Max_Flow(v,min(w,E[i].val));
            used += w;
            E[i].val -= w;
            E[i+1].val += w;
            if(used == Min)return Min;//必须加之优化圈1
        }
    }if(!used)dis[x] = -1;//必须加之优化圈2
    return used;
}
int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int x;
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;m;j++){
            scanf(&quot;%d&quot;,&amp;x);
            Link(Num(i,j),Num(i,j+1),x);
        }
    }
    for(int i=1;i&lt;n;i++){
        for(int j=1;j&lt;=m;j++){
            scanf(&quot;%d&quot;,&amp;x);
            Link(Num(i,j),Num(i+1,j),x);
        }
    }
    for(int i=1;i&lt;n;i++){
        for(int j=1;j&lt;m;j++){
            scanf(&quot;%d&quot;,&amp;x);
            Link(Num(i,j),Num(i+1,j+1),x);
        }
    }
    while(Bfs())Ans += Max_Flow(1,INF);
    printf(&quot;%d\n&quot;,Ans);
    return 0;
}
</code></pre><h1 id="1002">1002</h1>
<pre><code class = "c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
//by sssSSSay 基尔霍夫矩阵我当然是不会的QWQ
//eh^ zhao gui lv
//f[1] = 1;f[2] = 3;f[i] = f[i-1] + f[i-2]
//F[i] = f[i] * f[i] - (i % 2 == 0) * 4
using namespace std;
const int Maxn = 10001;
int n,LenPre,LenNow,LenTemp,LenAns;
int Pre[Maxn],Now[Maxn],Temp[Maxn],Ans[Maxn];
void Add(){
    int Len = max(LenPre,LenNow),x = 0;
    for(int i=1;i&lt;=Len;i++){
        Temp[i] = Pre[i] + Now[i] + x;
        x = Temp[i] / 10;
        Temp[i] %= 10;
    }while(x){Temp[++Len] = x % 10;x /= 10;}
    LenTemp = Len;
}
void Mul(){
    int Len;
    for(int i=1;i&lt;=LenPre;i++){
        Len = i + LenPre - 1;int x = 0;
        for(int j=1;j&lt;=LenPre;j++){
            Ans[i+j-1] += Pre[i] * Pre[j] + x;
            x = Ans[i+j-1] / 10;
            Ans[i+j-1] %= 10;
        }
        while(x &gt; 0){Ans[++Len] += x % 10;x /= 10;}
    }LenAns = Len;
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    LenPre = 1;Pre[1] = 1;
    LenNow = 1;Now[1] = 3;
    for(int i=2;i&lt;=n;i++){
        Add();
        LenPre = LenNow;memcpy(Pre,Now,sizeof(Now));
        LenNow = LenTemp;memcpy(Now,Temp,sizeof(Temp));
    }
    Mul();
    if(n % 2 == 1){
        for(int i=LenAns;i&gt;=1;i--)printf(&quot;%d&quot;,Ans[i]);
        printf(&quot;\n&quot;);
    }
    else {
        int Cur = 1;Ans[Cur] -= 4;
        while(Ans[Cur] &lt; 0){Ans[Cur] += 10;Ans[++Cur]--;}
        for(int i=LenAns;i&gt;=1;i--)printf(&quot;%d&quot;,Ans[i]);
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre><h1 id="1003">1003</h1>
<pre><code class = "c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
//By sssSSSay
//DP 有点类似区间DP 在天数上跑
typedef long long LL;
#define INF 100000007
using namespace std;
const int Maxn = 110;
int H[Maxn],dis[Maxn],q[Maxn*Maxn],Path[Maxn],Temp[Maxn];
LL f[Maxn],Dp[Maxn][Maxn];
int n,m,k,e,u,v,c,x,y,z,d,K,tot,Ans;
bool vis[Maxn],Judge[Maxn][Maxn],Can[Maxn];
struct node {int to,val,next;}E[Maxn];
void Add(int u,int v,int c){E[++tot].to = v;E[tot].val = c;E[tot].next = H[u];H[u] = tot;}
int Spfa(int a,int b){
    for(int i=1;i&lt;=m;i++){
        dis[i] = INF;
        vis[i] = 0;
        Can[i] = 0;
    }
    for(int i=1;i&lt;=m;i++)for(int j=a;j&lt;=b;j++)if(Judge[i][j])Can[i] = 1;
    int h = 1,t = 1;dis[1] = 0;q[h] = 1;Path[1] = -1;
    while(h &lt;= t){
        int u = q[h];
        vis[u] = 0;
        for(int i=H[u];i;i=E[i].next){
            int v = E[i].to;
            if(Can[v])continue;
            if(dis[u] + E[i].val &lt; dis[v]){
                dis[v] = dis[u] + E[i].val;
                Path[v] = u;
                if(!vis[v]){
                    vis[v] = 1;
                    q[++t] = v;
                }
            }
        }h++;
    }return dis[m];
}
int main(){
    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;e);
    for(int i=1;i&lt;=e;i++){
        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;c);
        Add(u,v,c);Add(v,u,c);
    }
    scanf(&quot;%d&quot;,&amp;d);
    for(int i=1;i&lt;=d;i++){
        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
        for(int j=y;j&lt;=z;j++)Judge[x][j] = 1;
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=i;j&lt;=n;j++)Dp[i][j] = (LL)Spfa(i,j);
	//预处理i和j之间跑同一条路时的最小花费
    }
    for(int i=1;i&lt;=n;i++){
        f[i] = (LL)Dp[1][i] * (LL)i;//初值
        for(int j=0;j&lt;i;j++)f[i] = min(f[i],f[j] + (LL)k + Dp[j+1][i] * (LL)(i - j));
    }//然后枚举一个断点
    printf(&quot;%d\n&quot;,f[n]);
    return 0;
}
</code></pre><h1 id="1004">1004</h1>
<pre><code class = "c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
//置换群什么东西先挖个坑
//这道题可用组合数来写一写┑(￣Д ￣)┍
typedef long long LL;
using namespace std;
const int Maxn = 201;
int C[Maxn][Maxn];
int Sr,Sg,Sb,n,p,m;
void Solve(){
    for(int i=2;i&lt;=n+1;i++){//递推组合数
        for(int j=0;j&lt;=i;j++){
            C[i][j] = (C[i][j] + C[i-1][j]) % p;
            if(j != 0)C[i][j] = (C[i][j] + C[i-1][j-1]) % p;
        }
    }
}
LL Pow(int a,int n){
    int c = 1;
    while(n){//快速幂
        if(n &amp; 1)c = (c * a) % p;
        a = (a * a) % p;
        n = n &gt;&gt; 1;
    }return c;
}
int main(){
    scanf(&quot;%d%d%d%d%d&quot;,&amp;Sr,&amp;Sb,&amp;Sg,&amp;m,&amp;p);
    C[1][0] = 1;C[1][1] = 1;
    n = Sr + Sb + Sg;Solve();//每个排列通过m中变换可以变出m+1种
    LL S = ((LL)C[n][Sr] * (LL)C[n - Sr][Sg]) % p;//S是理论上所有的排列
    printf(&quot;%lld&quot;,(S * Pow(m + 1,p - 2)) % p);//S需要除以(m+1)而m+1&lt;p 所以m+1的逆元是Pow那个东西
    // while(1);
    return 0;
}
</code></pre><h1 id="1005">1005</h1>
<pre><code class = "c++">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
//Prufer序列 任何一颗无根树都可以对应一个唯一的Prufer序列
//题意即为求Prufer序列的个数 而某个点出现的次数与度数有关
//组合数解一解就可以了 数很大要质因数分解然后高精乘乘起来
#define p 1000000
using namespace std;
const int Maxn = 1010;
int n,d[Maxn],pri[Maxn*Maxn],Ans[Maxn],LenAns,tot,cnt,m,num[Maxn];
inline bool Judge(int x){int N = sqrt(x);
    for(int i=2;i&lt;=N;i++)if(x % i == 0)return 0;
    return 1;
}
void Mul(int x){//乘法
    for(int i=1;i&lt;=LenAns;i++)Ans[i] *= x;
    for(int i=1;i&lt;=LenAns;i++){
        Ans[i + 1] += Ans[i] / p;
        Ans[i] %= p;
    }
    while(Ans[LenAns + 1] &gt; 0){LenAns++;Ans[LenAns + 1] += Ans[LenAns] / p;Ans[LenAns]  %= p;}
}
void Solve(int x,int c){//质因数分解
    for(int i=1;i&lt;=x;i++){
        int k = i;
        for(int j=1;j&lt;=cnt;j++){
            if(k &lt;= 1)break;
            while(k % pri[j] == 0){
                num[j] += c;
                k /= pri[j];
            }
        }
    }
}
void Print(){
    for(int i=LenAns;i&gt;=1;i--){
        if(i == LenAns)printf(&quot;%d&quot;,Ans[i]);
        else printf(&quot;%06d&quot;,Ans[i]);
    }printf(&quot;\n&quot;);
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);Ans[1] = 1;LenAns = 1;
    if(n == 1){//特判
        scanf(&quot;%d&quot;,&amp;d[1]);
        if(d[1] == 0)printf(&quot;1\n&quot;);
        else printf(&quot;0\n&quot;);
        return 0;
    }
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;d[i]);
        if(d[i] == 0){
            printf(&quot;0\n&quot;);
            return 0;
        }
        else if(d[i] != -1)tot += d[i] - 1;
        else m++;
    }
    if(tot &gt; n - 2){//判断各种无解的情况
        printf(&quot;0\n&quot;);
        return 0;
    }
    for(int i=2;i&lt;=1000;i++)if(Judge(i))pri[++cnt] = i;
    Solve(n - 2,1);Solve(n - 2 - tot,-1);//质因数分解
    for(int i=1;i&lt;=n;i++)if(d[i] != -1)Solve(d[i] - 1,-1);
    for(int i=1;i&lt;=cnt;i++){
        for(int j=1;j&lt;=num[i];j++)Mul(pri[i]);//乘起来
    }
    for(int i=1;i&lt;=n-tot-2;i++)Mul(m);
    Print();
    return 0;
}
</code></pre><h1 id="1006">1006</h1>
<pre><code class = "c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
//题意给出的首先要知道是一张弦图。。即没有长度大于3的环
//弦图的染色用完美消除序列搞一搞 构造方式代码里有
//然后在这个序列上倒着贪心染色即可
using namespace std;

const int Maxn = 100100;

struct node {int to,next;}E[3000010];

int n,m,q[Maxn],d[Maxn],col[Maxn],hash[Maxn],tot,H[Maxn],Ans;
bool vis[Maxn];

void Insert(int u,int v){E[++tot].to = v;E[tot].next = H[u];H[u] = tot;}

int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++){
        int x,y;scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        Insert(x,y);Insert(y,x);
    }
    for(int i=n;i&gt;=1;i--){//完美消除序列的构造
        int t = 0;
        for(int j=1;j&lt;=n;j++)if(!vis[j] &amp;&amp; d[j] &gt;= d[t])t = j;
        vis[t] = 1;q[i] = t;
        for(int j=H[t];j;j=E[j].next)d[E[j].to]++;
    }
    for(int i=n;i&gt;=1;i--){//倒着贪心
        int u = q[i],j;
        for(int k=H[u];k;k=E[k].next)hash[col[E[k].to]] = i;
        for(j=1;;j++)if(hash[j] != i)break;
        col[u] = j;if(j &gt; Ans)Ans = j;
    }
    printf(&quot;%d\n&quot;,Ans);
    // while(1);
    return 0;
}
</code></pre>
<h1 id="1007"> 1007</h1>
<pre><code class = "c++">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
//基础计算几何
//按照斜率排一下序 维护一个从上可见直线编号的栈即可
//判断交点位置来弹出不可见的直线
#define eps 1e-8
//坑爹精度问题
using namespace std;

const int Maxn = 500010;

struct node {double a,b;int p;}l[Maxn];

double p[Maxn];
int n,top,s[Maxn],Ans[Maxn];

bool comp(node x,node y){
    if(fabs(x.a - y.a) &lt; eps)return x.b &lt; y.b;
    return x.a &gt; y.a;
}

double Solve(int x,int y){return (l[y].b - l[x].b) / (l[x].a - l[y].a);}

int main(){
    // freopen(&quot;bzoj_1007.in&quot;,&quot;r&quot;,stdin);
    // freopen(&quot;bzoj_1007.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){scanf(&quot;%lf%lf&quot;,&amp;l[i].a,&amp;l[i].b);l[i].p = i;}
    sort(l + 1,l + n + 1,comp);
    for(int i=1;i&lt;=n;i++){
        while(top){
            if(fabs(l[s[top]].a - l[i].a) &lt; eps)top--;//斜率相同覆盖(之前y轴也排过序)
            else if(top &gt; 1 &amp;&amp; Solve(i,s[top]) &gt;= Solve(s[top],s[top - 1]))top--;//交点关系
            else break;
        }s[++top] = i;//加入
    }
    for(int i=1;i&lt;=top;i++)Ans[l[s[i]].p] = 1;//按标号排序输出
    for(int i=1;i&lt;=n;i++)if(Ans[i])printf(&quot;%d &quot;,i);
    // while(1);
    return 0;
}
</code></pre>
<h1 id="1008"> 1008</h1>
<pre><code class = "c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
//BZOJ难得一遇的水题
#define p 100003LL
//直接乘一下就行……
typedef long long LL;

using namespace std;

LL m,n;

LL Pow(LL a,LL n){
    LL c = 1;
    while(n){
        if(n &amp; 1)c = (c * a) % p;
        a = (a * a) % p;
        n = n / 2;
    }return c % p;
}

int main(){
    scanf(&quot;%lld%lld&quot;,&amp;m,&amp;n);
    // printf(&quot;%d\n&quot;,Pow(m,n));
    LL Temp = Pow(m,n) - (Pow(m - 1,n - 1) * m),j = 1;
    // printf(&quot;%lld\n&quot;,Temp);
    while(Temp &lt; 0)Temp += Pow(2,j++) * p;
    printf(&quot;%lld\n&quot;,Temp % p);
    // while(1);
    return 0;
}
</code></pre><h1 id="1009">1009</h1>
<pre><code calss = "c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
//方程 : dp[i][j] = Sigma ( dp[i-1][k] * a[k][j] ).0&lt;=k&lt;=m-1
//这个式子其实是dp数组和a数组的矩阵乘 所以可以写成dp = dp * a
//最后快速幂加速 --- sssSSSay
using namespace std;

const int M = 80;

int dp[M][M],a[M][M],next[M],p,n,m;
char s[M];

void Mul(int a[M][M],int b[M][M],int c[M][M]){//矩阵乘法
    int d[M][M];
    for(int i=0;i&lt; m;i++){
        for(int j=0;j&lt; m;j++){
            d[i][j] = 0;
            for(int k=0;k&lt; m;k++)d[i][j] = (d[i][j] + a[i][k] * b[k][j]) % p;
        }
    }
    for(int i=0;i&lt; m;i++){
        for(int j=0;j&lt; m;j++)c[i][j] = d[i][j];
    }
}

int main(){
    freopen(&quot;bzoj_1009.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;bzoj_1009.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p);
    scanf(&quot;%s&quot;,(s + 1));int j = 0;
    for(int i=2;i&lt;=m;i++){//处理Next表
        while(j &amp;&amp; s[i] != s[j + 1])j = next[j];
        if(s[i] == s[j + 1])j++;next[i] = j;
    }
    for(int i=0;i&lt; m;i++){//枚举在哪一位失配
        for(int j=0;j&lt;=9;j++){//枚举这一位准考证是什么
            int t = i;while(t&gt;0 &amp;&amp; s[t + 1] - &#39;0&#39; != j)t = next[t];//找匹配在哪里
            if(s[t + 1] - &#39;0&#39; == j)a[i][t+1]++;//由i转移到t的数+1
            else a[i][0]++;//重新到第一位 即无法匹配
        }
    }
    dp[0][0] = 1;//初始化
    while(n){//快速幂
        if(n &amp; 1)Mul(dp,a,dp);
        Mul(a,a,a);
        n &gt;&gt;= 1;
    }int Sum = 0;
    for(int i=0;i&lt; m;i++)Sum = (Sum + dp[0][i]) % p;//最后一个阶段的所有状态相加即为答案
    printf(&quot;%d\n&quot;,Sum);
    // while(1);
    return 0;
}
</code></pre><h1 id = "1010">1010</h1>
<pre><code class = "c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

typedef long long LL;

using namespace std;

const int Maxn = 50010;

int q[Maxn],n,l,c;
LL a[Maxn],dp[Maxn],g[Maxn];

double Slope(int k,int j){//斜率公式
    return (  (dp[j] + g[j]*g[j] + 2 * c * g[j])  -  (dp[k] + g[k] * g[k] + 2 * c * g[k] )  ) / (2.0* (g[j] - g[k]) );
}

int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;l);c = l + 1;
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
        g[i] = g[i-1] + a[i];
    }
    for(LL i=1;i&lt;=n;i++)g[i] += i;
    int h = 1,t = 0;q[++t] = 0;
    for(int i=1;i&lt;=n;i++){//维护单调队列
        while(h &lt; t &amp;&amp; Slope(q[h],q[h+1]) &lt;= g[i])h++;//淘汰不优的点
	//(因为g[i]是递增的,所以该点一定不能成为别的i的答案)
        int w = q[h];//从队首取出最优答案
        dp[i] = dp[w] + (g[i] - g[w] - (LL)c) * (g[i] - g[w] - (LL)c);
        while(h &lt; t &amp;&amp; Slope(q[t],i) &lt; Slope(q[t-1],q[t]))t--;
        q[++t] = i;//维护下凸性并加入i点
    }printf(&quot;%lld\n&quot;,dp[n]);
    // while(1);
    return 0;
}
</code></pre>




<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="10005" data-title="BZOj" data-url="https://ssssssay.github.io/sssSSSay.github.io/2017/02/20/BZOJ%E4%BB%A3%E7%A0%81.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"sssSSSay"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->


<footer>
    <div class="links">
        <a href="{{site.baseurl}}/about/">About</a>
        <a href="{{site.baseurl}}/contact/">Contact</a>
    </div>
    <div class="theme" onclick="theme()" style="    background-image: url({{site.baseurl}}/images/theme.svg)"></div>
</footer>
{% include analytics.html %}

</body>
</html>
