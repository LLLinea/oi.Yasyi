# [BZOJ]1009
## 题意：
阿申准备报名参加GT考试，准考证号为N位数X1X2....Xn(0<=Xi <= 9),他不希望准考证号上出现不吉利的数字。
他的不吉利数学A1A2...Am(0<=Ai<=9)有M位，不出现是指X1X2...Xn中没有恰好一段等于A1A2...Am. A1和X1可以为
0
## 题解：
百度搜索sssSSSay QWQ
## 代码：
<pre><code class = "c++">#include &lt;time.h&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

#define val (o -&gt; v)
#define siz (o -&gt; s)
#define pre (o -&gt; p)
#define tag (o -&gt; t)
#define Lc (o -&gt; ch[0])
#define Rc (o -&gt; ch[1])

using namespace std;

const int Maxn = 101000;

struct Treap {
    int v,p,s,t;
    Treap* ch[2];
};

Treap* Root;
int n,m;

typedef pair&lt;Treap*,Treap*&gt; Troot;

int S(Treap* o){if(o == NULL){return 0;}return siz;}

Treap* NewNode(int k,int w){Treap* o = new Treap();val = k;pre = w;siz = 1;tag = 0;return o;}

void PushDown(Treap* o){
    if(o == NULL)return;
    if(!tag)return;
    if(Lc)Lc -&gt; t ^= 1;
    if(Rc)Rc -&gt; t ^= 1;
    tag = 0;swap(Lc,Rc);
}

void Update(Treap* o){siz = 1 + S(Lc) + S(Rc);}

Treap* Merge(Treap* A,Treap* B){
    if(A == NULL)return B;
    if(B == NULL)return A;
    PushDown(A);PushDown(B);
    if(A -&gt; p &lt; B -&gt; p){A -&gt; ch[1] = Merge(A -&gt; ch[1],B);Update(A);return A;}
    else {B -&gt; ch[0] = Merge(A,B -&gt; ch[0]);Update(B);return B;}
}

Troot Split(Treap* o,int k){
    Troot Temp(NULL,NULL);
    if(o == NULL)return Temp;
    PushDown(o);int LcSize = S(Lc),RcSize = S(Rc);
    if(k &lt;= LcSize){
        Temp = Split(Lc,k);Lc = Temp.second;
        Update(o);Temp.second = o;
    }
    else {
        Temp = Split(Rc,k - LcSize - 1);
        Rc = Temp.first;Update(o);Temp.first = o;
    }return Temp;
}

void Insert(Treap* &amp;o,int k){
    Treap* Now = NewNode(k,rand());
    PushDown(o);o = Merge(o,Now);
}

void Turn(int L,int R){
    Troot Temp1 = Split(Root,R);
    Troot Temp2 = Split(Temp1.first,L-1);
    if(Temp2.second != NULL)Temp2.second -&gt; t ^= 1;
    Root = NULL;
    Root = Merge(Temp2.first,Temp2.second);
    Root = Merge(Root,Temp1.second);
}

void Ans(Treap* o){
    if(tag != 0)PushDown(o);
    if(Lc != NULL)Ans(Lc);
    printf(&quot;%d &quot;,val);
    if(Rc != NULL)Ans(Rc);
}

int main(){
    freopen(&quot;phs.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;phs.out&quot;,&quot;w&quot;,stdout);
    srand(time(NULL));
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);Root = NULL;
    for(int i=1;i&lt;=n;i++)Insert(Root,i);
    for(int i=1;i&lt;=m;i++){
        int L,R;scanf(&quot;%d%d&quot;,&amp;L,&amp;R);
        Turn(L,R);
    }
    Ans(Root);
    return 0;
}
</code></pre>
